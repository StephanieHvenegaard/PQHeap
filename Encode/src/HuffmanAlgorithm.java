
import java.util.HashMap;

public class HuffmanAlgorithm {

    HashMap<Integer, String> dataCodes = new HashMap<>();
    HashMap<String, Integer> codeCodes = new HashMap<>();
    // 
    public void generateFreqCode(Element element, String code) {
        if (element.getData() instanceof Node) {
            Node node = (Node) element.getData();
            if (node.left == null && node.right == null) {
                codeCodes.put(code, (int) element.getData());
                return;
            }
            generateDataCode(node.left, code + "0");
            generateDataCode(node.right, code + "1");
        } else {
            codeCodes.put(code, (int) element.getData());
            return;
        }

    }
    // generates the hashmap  
    public void generateDataCode(Element element, String code) {
        if (element.getData() instanceof Node) {
            Node node = (Node) element.getData();
            if (node.left == null && node.right == null) {
                dataCodes.put((int) element.getData(), code);
                return;
            }
            generateDataCode(node.left, code + "0");
            generateDataCode(node.right, code + "1");
        } else {
            dataCodes.put((int) element.getData(), code);
            return;
        }

    }
    // Debugging prints the codes of all bytes in the huffman
    private void printCode(Element element, String code) {
        // base case; if the left and right are null 
        // then its a leaf node and we print 
        // the code s generated by traversing the tree.
        if (element.getData() instanceof Node) {
            Node node = (Node) element.getData();
            if (node.left == null && node.right == null) {

                // c is the character in the node 
                System.out.println(node.key + ":" + code);

                return;
            }

            // if we go to left then add "0" to the code. 
            // if we go to the right add"1" to the code. 
            // recursive calls for left and 
            // right sub-tree of the generated tree. 
            printCode(node.left, code + "0");
            printCode(node.right, code + "1");
        } else {
            // c is the character in the node 
            System.out.println(element.getKey() + ":" + code);

            return;
        }
    }
    // return Hashmap with codes/keys) and bytes of the huffman tree
    public HashMap<String, Integer> Decrypt(int[] bytefreq) {
        codeCodes.clear();

        // creating a priority queue q. 
        // makes a min-priority queue(min-heap). 
        PQHeap q = new PQHeap(bytefreq.length);

        for (int i = 0; i < bytefreq.length; i++) {
            // creating an object 
            Element e = new Element(bytefreq[i], i); //  Bytefreq = key | 0-255 data.
            // and add it to the priority queue. 
            q.insert(e);

        }
        // create a root node 
        Element root = null;

        // Here we will extract the two minimum value 
        // from the heap each time until 
        // its size reduces to 1, extract until 
        // all the nodes are extracted. 
        while (q.size() > 1) {
            // first min extract. 
            Element x = q.extractMin();
            // second min extarct. 
            Element y = q.extractMin();
            // to the sum of the frequency of the two nodes 
            // assigning values to the f node. 
            // saves key for new node 
            int key = y.getKey() + x.getKey();
            // Create new tree struck object            
            Node n = new Node(key);
            // first extracted node as left child. 
            n.left = x;
            // second extracted node as the right child. 
            n.right = y;
            // new node f which is equal 
            Element e = new Element(key, n);
            // marking the f node as the root node. 
            root = e;
            // add this node to the priority-queue. 
            q.insert(e);
        }

        generateFreqCode(root, "");
        return codeCodes;
    }
    // return Hashmap with byte(key) and codes of the huffman tree 
    public HashMap<Integer, String> Encrypt(int[] bytefreq) {
        dataCodes.clear();

        // creating a priority queue q. 
        // makes a min-priority queue(min-heap). 
        PQHeap q = new PQHeap(bytefreq.length);

        for (int i = 0; i < bytefreq.length; i++) {
            // creating an object 
            Element e = new Element(bytefreq[i], i); //  Bytefreq = key | 0-255 data.
            // and add it to the priority queue. 
            q.insert(e);

        }
        // create a root node 
        Element root = null;

        // Here we will extract the two minimum value 
        // from the heap each time until 
        // its size reduces to 1, extract until 
        // all the nodes are extracted. 
        while (q.size() > 1) {
            // first min extract. 
            Element x = q.extractMin();
            // second min extarct. 
            Element y = q.extractMin();
            // to the sum of the frequency of the two nodes 
            // assigning values to the f node. 
            // saves key for new node 
            int key = y.getKey() + x.getKey();
            // Create new tree struck object            
            Node n = new Node(key);
            // first extracted node as left child. 
            n.left = x;
            // second extracted node as the right child. 
            n.right = y;
            // new node f which is equal 
            Element e = new Element(key, n);
            // marking the f node as the root node. 
            root = e;
            // add this node to the priority-queue. 
            q.insert(e);
        }

        generateDataCode(root, "");
        return dataCodes;
    }
} 

// This code is contributed by Kunwar Desh Deepak Singh 
